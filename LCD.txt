MVM

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
entity lcd is
    Port ( rst : in  STD_LOGIC;
           clk_12mhz : in  STD_LOGIC;
           lcd_rs : out  STD_LOGIC;
           lcd_en : out  STD_LOGIC;
           lcd_data : out  STD_LOGIC_VECTOR (7 downto 0));
end lcd;
architecture Behavioral of lcd is
signal div:std_logic_vector(15 downto 0);
signal clk_fsm,lcd_rs_s:std_logic;
type state is (reset,func,mode,cur,clear,d0,d1,d2,d3,d4,hold);
signal ps1,nx:state;
signal dataout_s:std_logic_vector(7 downto 0);
begin
process(rst,clk_12mhz)
begin
	if(rst='1') then
		div<=(others=>'0');
	elsif(clk_12mhz'event and clk_12mhz='1') then
		div<=div+1;
	end if;
end process;
clk_fsm<=div(15);
process(rst,clk_fsm)
begin
	if(rst='1') then
		ps1<=reset;
	elsif(rising_edge(clk_fsm)) then
		ps1<=nx;
	end if;
end process;
process(ps1)
begin
case(ps1)is
	when reset=>
		nx<=func;
		lcd_rs_s<='0';
		dataout_s<="00111000";
	when func=>
		nx<=mode;
		lcd_rs_s<='0';
		dataout_s<="00111000";
	when mode=>
		nx<=cur;
		lcd_rs_s<='0';
		dataout_s<="00000110";
	when cur=>
		nx<=clear;
		lcd_rs_s<='0';
		dataout_s<="00001100";
	when clear=>
		nx<=d0;
		lcd_rs_s<='0';
		dataout_s<="00000001";
	when d0 =>
		lcd_rs_s<='1';
		dataout_s<="01010000";
		nx<=d1;
	when d1=>
		lcd_rs_s<='1';
		dataout_s<="01001001";
		nx<=d2;
	when d2=>
		lcd_rs_s<='1';
		dataout_s<="01000011";
		nx<=d3;
	when d3=>
		lcd_rs_s<='1';
		dataout_s<="01010100";
		nx<=d4;
	when d4=>
		lcd_rs_s<='1';
		dataout_s<="00100000";
		nx<=hold;
	when hold=>
		lcd_rs_s<='0';
		dataout_s<="00000000";
		nx<=hold;
	when others=>
		nx<=reset;
		lcd_rs_s<='0';
		dataout_s<="00000001";
	end case;
end process;
lcd_en<=clk_fsm;
lcd_rs<=lcd_rs_s;
lcd_data<=dataout_s;
end Behavioral;

TESTBENCH

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
ENTITY lcd_tb IS
END lcd_tb;
ARCHITECTURE behavior OF lcd_tb IS 
    COMPONENT lcd
    PORT(
         rst : IN  std_logic;
         clk_12mhz : IN  std_logic;
         lcd_rs : OUT  std_logic;
         lcd_en : OUT  std_logic;
         lcd_data : OUT  std_logic_vector(7 downto 0)
        );
    END COMPONENT;
   --Inputs
   signal rst : std_logic := '0';
   signal clk_12mhz : std_logic := '0';
 	--Outputs
   signal lcd_rs : std_logic;
   signal lcd_en : std_logic;
   signal lcd_data : std_logic_vector(7 downto 0);
   -- Clock period definitions
   constant clk_12mhz_period : time := 10 ns;
BEGIN
	-- Instantiate the Unit Under Test (UUT)
   uut: lcd PORT MAP (
          rst => rst,
          clk_12mhz => clk_12mhz,
          lcd_rs => lcd_rs,
          lcd_en => lcd_en,
          lcd_data => lcd_data
        );
   -- Clock process definitions
   clk_12mhz_process :process
   begin
		clk_12mhz <= '0';
		wait for clk_12mhz_period/2;
		clk_12mhz <= '1';
		wait for clk_12mhz_period/2;
   end process;
   -- Stimulus process
   stim_proc: process
   begin		
      rst<='1';
		wait for 20 ns;
		rst<='0';

      wait;
   end process;
END;
